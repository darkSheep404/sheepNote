<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SheepNote Flowchart</title>
    <link rel="stylesheet" href="styles.css">
    <script src="jsplumb.min.js"></script>
</head>
<body>
    <div class="toolbar">
        <button id="newNode" class="toolbar-btn">
            <span class="icon">+</span>æ–°å»ºèŠ‚ç‚¹
        </button>
        <button id="loadFlowchart" class="toolbar-btn">
            <span class="icon">ğŸ“‚</span>åŠ è½½æµç¨‹å›¾
        </button>
        <button id="save" class="toolbar-btn">
            <span class="icon">ğŸ’¾</span>ä¿å­˜æµç¨‹å›¾
        </button>
        <button id="toggleAllCode" class="toolbar-btn">
            <span class="icon">ğŸ“</span><span id="toggleAllCodeText">å±•å¼€æ‰€æœ‰ä»£ç </span>
        </button>
        <button id="refresh" class="toolbar-btn" style="margin-left: auto;">
            <span class="icon">âŸ³</span>åˆ·æ–°é¡µé¢
        </button>
    </div>
    
    <div id="searchPanel" class="search-panel">
        <input type="text" id="searchInput" placeholder="æœç´¢ç¬”è®°æˆ–è¾“å…¥æ–‡æœ¬">
        <div id="searchResults" class="search-results"></div>
        <div class="search-panel-buttons">
            <button id="useCustomText">ä½¿ç”¨è¾“å…¥æ–‡æœ¬</button>
            <button id="cancelSearch">å–æ¶ˆ</button>
        </div>
    </div>

    <div id="saveDialog" class="modal">
        <div class="modal-content">
            <h3>ä¿å­˜æµç¨‹å›¾</h3>
            <input type="text" id="flowchartName" placeholder="è¾“å…¥æµç¨‹å›¾åç§°">
            <div class="modal-buttons">
                <button id="confirmSave">ä¿å­˜</button>
                <button id="cancelSave">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div id="loadDialog" class="modal">
        <div class="modal-content">
            <h3>åŠ è½½æµç¨‹å›¾</h3>
            <div id="flowchartList" class="flowchart-list"></div>
            <div class="modal-buttons">
                <button id="cancelLoad">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <div id="contextMenu" class="context-menu">
        <div class="menu-item" id="addNextNode">æ·»åŠ ä¸‹ä¸€ä¸ªèŠ‚ç‚¹</div>
        <div class="menu-item" id="jumpToFile">è·³è½¬åˆ°æ–‡ä»¶</div>
        <div class="menu-item" id="toggleCode">å±•å¼€/æŠ˜å ä»£ç </div>
        <div class="menu-item" id="deleteNode">åˆ é™¤èŠ‚ç‚¹</div>
    </div>

    <div id="flowchartContainer"></div>

    <style>
        .toolbar-btn {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            margin: 0 4px;
            border: none;
            border-radius: 4px;
            background: #f0f0f0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toolbar-btn:hover {
            background: #e0e0e0;
        }

        .toolbar-btn .icon {
            margin-right: 8px;
        }

        .flowchart-node {
            padding: 10px;
            border-radius: 6px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 300px;
            transition: all 0.3s;
        }

        .flowchart-node .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .flowchart-node .node-title {
            font-weight: bold;
            margin: 0;
        }

        .flowchart-node .node-filename {
            color: #666;
            font-size: 0.9em;
        }

        .flowchart-node .node-content {
            display: none;
            margin-top: 8px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }

        .flowchart-node.expanded .node-content {
            display: block;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .modal-content {
            position: relative;
            background: white;
            margin: 10% auto;
            padding: 20px;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .flowchart-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .flowchart-list-item {
            padding: 10px;
            margin: 5px 0;
            background: #f5f5f5;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .flowchart-list-item:hover {
            background: #e0e0e0;
        }

        .flowchart-node .node-tags {
            margin-top: 4px;
            font-size: 0.8em;
            color: #666;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .flowchart-node .node-tag {
            background: #e0e0e0;
            padding: 2px 6px;
            border-radius: 12px;
            color: #444;
        }
    </style>

    <script>
        // æ·»åŠ åˆ·æ–°æŒ‰é’®çš„äº‹ä»¶ç›‘å¬ï¼ˆæ”¾åœ¨æœ€å‰é¢ï¼‰
        document.getElementById('refresh').addEventListener('click', () => {
            window.location.reload();
        });

        const instance = jsPlumb.getInstance({
            Container: "flowchartContainer",
            ConnectionsDetachable: true,
            EndpointStyle: { fill: "#2196F3" },
            ConnectorStyle: { stroke: "#2196F3", strokeWidth: 2 }
        });

        let nodeCounter = 0;
        let currentMousePos = { x: 0, y: 0 };
        let activeNode = null;

        // è·Ÿè¸ªé¼ æ ‡ä½ç½®
        document.addEventListener('mousemove', (e) => {
            currentMousePos.x = e.clientX;
            currentMousePos.y = e.clientY;
        });

        document.getElementById('newNode').addEventListener('click', () => {
            showSearchPanel();
        });

        document.getElementById('save').addEventListener('click', () => {
            document.getElementById('saveDialog').style.display = 'block';
        });

        document.getElementById('confirmSave').addEventListener('click', async () => {
            const name = document.getElementById('flowchartName').value;
            if (name) {
                try {
                    const flowchartContent = saveCurrentFlowchart();
                    // ä¸ºæ‰€æœ‰å¸¦ noteData çš„èŠ‚ç‚¹æ·»åŠ æµç¨‹å›¾åç§°ä½œä¸º tag
                    flowchartContent.nodes.forEach(node => {
                        if (node.noteData) {
                            const tags = node.noteData.tags || [];
                            if (!tags.includes(name)) {
                                tags.push(name);
                                node.noteData.tags = tags;
                            }
                        }
                    });

                    const flowchartData = {
                        name: name,
                        content: flowchartContent
                    };
                    await window.saveFlowchart(flowchartData);
                    document.getElementById('saveDialog').style.display = 'none';
                } catch (error) {
                    console.error('ä¿å­˜å¤±è´¥:', error);
                }
            }
        });

        document.getElementById('cancelSave').addEventListener('click', () => {
            document.getElementById('saveDialog').style.display = 'none';
        });

        let isAllCodeExpanded = false;
        const MAX_CONNECTIONS = 5;

        document.getElementById('toggleAllCode').addEventListener('click', () => {
            isAllCodeExpanded = !isAllCodeExpanded;
            const nodes = document.querySelectorAll('.flowchart-node');
            nodes.forEach(node => {
                if (isAllCodeExpanded) {
                    node.classList.add('expanded');
                } else {
                    node.classList.remove('expanded');
                }
            });
            document.getElementById('toggleAllCodeText').textContent = 
                isAllCodeExpanded ? 'æŠ˜å æ‰€æœ‰ä»£ç ' : 'å±•å¼€æ‰€æœ‰ä»£ç ';
        });

        document.getElementById('loadFlowchart').addEventListener('click', async () => {
            try {
                const flowcharts = await window.getFlowcharts();
                displayFlowchartList(flowcharts);
                document.getElementById('loadDialog').style.display = 'block';
            } catch (error) {
                console.error('åŠ è½½æµç¨‹å›¾åˆ—è¡¨å¤±è´¥:', error);
            }
        });

        document.getElementById('cancelLoad').addEventListener('click', () => {
            document.getElementById('loadDialog').style.display = 'none';
        });

        function displayFlowchartList(flowcharts) {
            const listContainer = document.getElementById('flowchartList');
            listContainer.innerHTML = '';
            
            flowcharts.forEach(flowchart => {
                const item = document.createElement('div');
                item.className = 'flowchart-list-item';
                item.textContent = flowchart.name;
                item.addEventListener('click', async () => {
                    try {
                        console.log('await loadFlowchart:', flowchart.id);
                        await loadFlowchart(flowchart.id);
                        document.getElementById('loadDialog').style.display = 'none';
                    } catch (error) {
                        console.error('åŠ è½½æµç¨‹å›¾å¤±è´¥:', error);
                    }
                });
                listContainer.appendChild(item);
            });
        }

        function saveCurrentFlowchart() {
            const nodes = Array.from(document.querySelectorAll('.flowchart-node')).map(node => {
                const nodeData = {
                    id: node.id,
                    text: node.querySelector('.node-title').textContent,
                    position: {
                        x: parseInt(node.style.left),
                        y: parseInt(node.style.top)
                    }
                };

                if (node.dataset.notePath) {
                    nodeData.noteData = {
                        noteFilePath: node.dataset.notePath,
                        id: node.dataset.noteId,
                        tags: node.dataset.tags || ''
                    };
                }

                return nodeData;
            });

            const connections = instance.getConnections().map(conn => ({
                sourceId: conn.sourceId,
                targetId: conn.targetId
            }));

            return {
                nodes,
                connections
            };
        }

        async function loadFlowchart(flowchartId) {
            try {
                console.log('loadFlowchart(flowchartId):', flowchartId);
                const flowchartData = await window.getFlowchartById(flowchartId);
                if (!flowchartData) {
                    console.error('æœªæ‰¾åˆ°æµç¨‹å›¾æ•°æ®');
                    return;
                }

                const data = flowchartData;
                if (!data || !data.nodes || !Array.isArray(data.nodes)) {
                    console.error('æµç¨‹å›¾æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                    return;
                }
                
                // æ¸…ç©ºç°æœ‰çš„æµç¨‹å›¾
                instance.reset();
                const container = document.getElementById('flowchartContainer');
                container.innerHTML = '';
                nodeCounter = 0;

                // åˆ›å»ºèŠ‚ç‚¹
                data.nodes.forEach(nodeData => {
                    // ç¡®ä¿ noteData çš„å­—æ®µåç§°æ­£ç¡®
                    let noteDataForCreate = null;
                    if (nodeData.noteData) {
                        noteDataForCreate = {
                            noteFilePath: nodeData.noteData.noteFilePath || nodeData.noteData.path,
                            id: nodeData.noteData.id,
                            selectCode: nodeData.noteData.selectCode,
                            tags: nodeData.noteData.tags
                        };
                    }

                    const node = createNode(nodeData.text, nodeData.position, noteDataForCreate);
                    node.id = nodeData.id;
                });

                // åˆ›å»ºè¿æ¥
                if (data.connections && Array.isArray(data.connections)) {
                    data.connections.forEach(conn => {
                        if (conn.sourceId && conn.targetId) {
                            instance.connect({
                                source: conn.sourceId,
                                target: conn.targetId,
                                connector: ["Bezier"],
                                paintStyle: { stroke: "#2196F3", strokeWidth: 2 }
                            });
                        }
                    });
                }

                // æ›´æ–°èŠ‚ç‚¹è®¡æ•°å™¨
                const nodeIds = data.nodes.map(n => parseInt(n.id.replace('node-', '')));
                nodeCounter = Math.max(...nodeIds, 0);
            } catch (error) {
                console.error('åŠ è½½æµç¨‹å›¾å¤±è´¥:', error);
            }
        }

        function displaySearchResults(results, position = null, sourceNode = null) {
            const searchResults = document.getElementById('searchResults');
            searchResults.innerHTML = '';
            
            if (!Array.isArray(results)) {
                console.error('æœç´¢ç»“æœæ ¼å¼ä¸æ­£ç¡®');
                return;
            }
            
            results.forEach(result => {
                if (!result) return;

                const item = document.createElement('div');
                item.className = 'search-result-item';
                item.textContent = result.noteTitle || 'æœªå‘½åç¬”è®°';
                item.addEventListener('click', () => {
                    const pos = position || currentMousePos;
                    const newNode = createNode(result.noteTitle || 'æœªå‘½åç¬”è®°', pos, {
                        noteFilePath: result.noteFilePath,
                        id: result.id,
                        selectCode: result.selectCode,
                        tags: result.tags
                    });
                    
                    if (sourceNode) {
                        instance.connect({
                            source: sourceNode.id,
                            target: newNode.id,
                            connector: ["Bezier"],
                            paintStyle: { stroke: "#2196F3", strokeWidth: 2 }
                        });
                    }
                    
                    hideSearchPanel();
                });
                searchResults.appendChild(item);
            });
        }

        function createNode(text, position, noteData = null) {
            const nodeId = `node-${++nodeCounter}`;
            const node = document.createElement('div');
            node.id = nodeId;
            node.className = 'flowchart-node';
            
            // åˆ›å»ºèŠ‚ç‚¹å†…å®¹ç»“æ„
            const header = document.createElement('div');
            header.className = 'node-header';
            
            const title = document.createElement('h3');
            title.className = 'node-title';
            title.textContent = text || 'æœªå‘½åèŠ‚ç‚¹';
            
            header.appendChild(title);
            node.appendChild(header);

            if (noteData) {
                if (noteData.noteFilePath) {
                    const filename = document.createElement('div');
                    filename.className = 'node-filename';
                    filename.textContent = noteData.noteFilePath.split(/[/\\]/).pop();
                    node.appendChild(filename);
                }

                if (noteData.selectCode) {
                    const content = document.createElement('div');
                    content.className = 'node-content';
                    content.textContent = noteData.selectCode;
                    node.appendChild(content);
                }

                if (noteData.tags) {
                    try {
                        const tags = document.createElement('div');
                        tags.className = 'node-tags';
                        const tagArray = noteData.tags.split(',')
                            .map(tag => tag.trim())
                            .filter(tag => tag.length > 0);
                        if (tagArray.length > 0) {
                            tags.innerHTML = tagArray.map(tag => 
                                `<span class="node-tag">${tag}</span>`
                            ).join('');
                            node.appendChild(tags);
                            node.dataset.tags = noteData.tags;
                        }
                    } catch (e) {
                        console.error('å¤„ç†æ ‡ç­¾æ—¶å‡ºé”™:', e);
                    }
                }

                if (noteData.noteFilePath) node.dataset.notePath = noteData.noteFilePath;
                if (noteData.id) node.dataset.noteId = noteData.id;
            }

            node.style.left = `${position?.x || 0}px`;
            node.style.top = `${position?.y || 0}px`;

            document.getElementById('flowchartContainer').appendChild(node);
            
            // ç‚¹å‡»èŠ‚ç‚¹å±•å¼€/æŠ˜å ä»£ç 
            node.addEventListener('click', (e) => {
                if (e.target === node || e.target.parentNode === node) {
                    node.classList.toggle('expanded');
                }
            });

            instance.draggable(nodeId);

            instance.addEndpoint(nodeId, {
                anchor: "Right",
                isSource: true,
                maxConnections: MAX_CONNECTIONS,
                connectorStyle: { stroke: "#2196F3", strokeWidth: 2 },
                connectionType: "basic"
            });

            instance.addEndpoint(nodeId, {
                anchor: "Left",
                isTarget: true,
                maxConnections: MAX_CONNECTIONS,
                connectorStyle: { stroke: "#2196F3", strokeWidth: 2 },
                connectionType: "basic"
            });

            node.addEventListener('contextmenu', showContextMenu);
            return node;
        }

        function showContextMenu(e) {
            e.preventDefault();
            activeNode = e.target.closest('.flowchart-node');
            if (!activeNode) return;

            const menu = document.getElementById('contextMenu');
            menu.style.display = 'block';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';

            const jumpToFileItem = document.getElementById('jumpToFile');
            const toggleCodeItem = document.getElementById('toggleCode');
            
            jumpToFileItem.style.display = activeNode.dataset.notePath ? 'block' : 'none';
            toggleCodeItem.style.display = activeNode.querySelector('.node-content') ? 'block' : 'none';

            // æ£€æŸ¥è¿æ¥æ•°é‡
            const connections = instance.getConnections({ source: activeNode.id });
            document.getElementById('addNextNode').style.display = 
                connections.length >= MAX_CONNECTIONS ? 'none' : 'block';
        }

        document.getElementById('addNextNode').addEventListener('click', () => {
            if (activeNode) {
                const rect = activeNode.getBoundingClientRect();
                const newPosition = {
                    x: rect.right + 100,
                    y: rect.top
                };
                showSearchPanel(newPosition, activeNode);
            }
            hideContextMenu();
        });

        document.getElementById('jumpToFile').addEventListener('click', () => {
            if (activeNode && activeNode.dataset.notePath) {
                window.jumpToFile(activeNode.dataset.notePath);
            }
            hideContextMenu();
        });

        document.getElementById('toggleCode').addEventListener('click', () => {
            if (activeNode) {
                activeNode.classList.toggle('expanded');
            }
            hideContextMenu();
        });

        async function showSearchPanel(position = null, sourceNode = null) {
            const searchPanel = document.getElementById('searchPanel');
            searchPanel.style.display = 'block';
            
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            searchInput.value = '';
            searchInput.focus();
            
            const newSearchInput = searchInput.cloneNode(true);
            searchInput.parentNode.replaceChild(newSearchInput, searchInput);
            
            newSearchInput.addEventListener('input', async (e) => {
                const query = e.target.value;
                if (query.length > 0) {
                    try {
                        const results = await window.searchNotes(query);
                        if (Array.isArray(results)) {
                            displaySearchResults(results, position, sourceNode);
                        } else {
                            console.error('æœç´¢ç»“æœæ ¼å¼ä¸æ­£ç¡®:', results);
                        }
                    } catch (error) {
                        console.error('æœç´¢å¤±è´¥:', error);
                        searchResults.innerHTML = '<div class="search-error">æœç´¢å¤±è´¥ï¼Œè¯·é‡è¯•</div>';
                    }
                } else {
                    searchResults.innerHTML = '';
                }
            });
        }

        document.getElementById('useCustomText').addEventListener('click', () => {
            const text = document.getElementById('searchInput').value;
            if (text) {
                createNode(text, currentMousePos);
                hideSearchPanel();
            }
        });

        document.getElementById('cancelSearch').addEventListener('click', hideSearchPanel);

        function hideSearchPanel() {
            document.getElementById('searchPanel').style.display = 'none';
            document.getElementById('searchInput').value = '';
            document.getElementById('searchResults').innerHTML = '';
        }

        document.getElementById('deleteNode').addEventListener('click', () => {
            if (activeNode) {
                instance.remove(activeNode);
            }
            hideContextMenu();
        });

        document.addEventListener('click', hideContextMenu);

        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            activeNode = null;
        }
    </script>
</body>
</html> 